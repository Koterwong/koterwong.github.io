<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://koterwong.top').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Android Heroes第一章  Android体系和系统架构1.1、Android系统架构：大致分为四层，即Linux内核层、库和运行时、FrameWork层和应用层。Android系统体系架构鼓励系统组件重用，共享组件间的数据，并且定义组件的访问权限控制。可以说，这些层次组件结构即使相互独立，又是相互关联。 从Android设计者的角度来看整个Android之间的架构，设计者们希望Andr">
<meta property="og:type" content="article">
<meta property="og:title" content="AndroidHeroes读书笔记">
<meta property="og:url" content="http://koterwong.top/2016/03/15/AndroidHeroes%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Koterwong的随笔">
<meta property="og:description" content="Android Heroes第一章  Android体系和系统架构1.1、Android系统架构：大致分为四层，即Linux内核层、库和运行时、FrameWork层和应用层。Android系统体系架构鼓励系统组件重用，共享组件间的数据，并且定义组件的访问权限控制。可以说，这些层次组件结构即使相互独立，又是相互关联。 从Android设计者的角度来看整个Android之间的架构，设计者们希望Andr">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-03-14T16:00:00.000Z">
<meta property="article:modified_time" content="2020-01-03T12:59:24.150Z">
<meta property="article:author" content="Koterwong">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://koterwong.top/2016/03/15/AndroidHeroes%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>AndroidHeroes读书笔记 | Koterwong的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Koterwong的随笔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koterwong.top/2016/03/15/AndroidHeroes%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Koterwong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koterwong的随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AndroidHeroes读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-03-15 00:00:00" itemprop="dateCreated datePublished" datetime="2016-03-15T00:00:00+08:00">2016-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/03/15/AndroidHeroes%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/03/15/AndroidHeroes%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Android-Heroes"><a href="#Android-Heroes" class="headerlink" title="Android Heroes"></a>Android Heroes</h2><h4 id="第一章-Android体系和系统架构"><a href="#第一章-Android体系和系统架构" class="headerlink" title="第一章  Android体系和系统架构"></a>第一章  Android体系和系统架构</h4><p>1.1、Android系统架构：大致分为四层，即Linux内核层、库和运行时、FrameWork层和应用层。Android系统体系架构鼓励系统组件重用，共享组件间的数据，并且定义组件的访问权限控制。可以说，这些层次组件结构即使相互独立，又是相互关联。 从Android设计者的角度来看整个Android之间的架构，设计者们希望Android架构能够起到承上启下的作用，让应用的各个组件之间结构，并且通过框架统一的调度、管理。</p>
<a id="more"></a>

<ul>
<li>Linux内核层：Linux内核层是Android系统最底层最核心的部分，可以在手机上查看我们使用的Linux内核版本。它包含了Android系统的核心服务，硬件驱动，进程管理，安全系统等等。</li>
<li>Standard Libraries：</li>
<li>FrameWork：</li>
<li>Application：</li>
</ul>
<p>Dalvik与Art：Android为每App分配了Dalvik虚拟机来保证了互相之间不受干扰，并保证独立。Dalvik虚拟机的特点是运行时编译，而Android5.0之后Art模式取代了Dalvik，它的特点是安装时就进行编译，执行效率更高。</p>
<p>2、Android系统源码目录</p>
<p><code>Makefile</code> （描述Android各个组件间的联系并指导它们进行自动化编译）<br><code>bionic</code> (bionic C库)<br><code>bootable</code> (启动引导相关代码)<br><code>build</code> (系统编译规则等基础开发包配置)<br><code>cts</code> （Google兼容性测试标准）<br><code>dalvik</code> （Dalvik虚拟机）<br><code>development</code> （应用程序开发相关）<br><code>external</code> （android使用的一些开源模块）<br><code>frameworks</code> （Framework框架核心）<br><code>hardware</code> （厂商硬件适配层HAL）<br><code>out</code> （编译完成后的代码输出目录）<br><code>packages</code> （应用程序包）<br><code>prebuilt</code> （x86和arm架构下预编译资源）<br><code>sdk</code> （sdk及模拟器）<br><code>system</code> （底层文件系统库、应用及组件）<br><code>vendor</code> （厂商定制代码）</p>
<p>3、Android系统目录</p>
<p>手机通过adb连接电脑后，可以通过<code>ls</code>命令来查看。</p>
<p><code>/system</code>和<code>/app</code>是开发者最需要关注的两个目录。</p>
<p>system目录</p>
<p>主要包括:<code>system/app</code>主要存在系统的App，<code>system/bin</code>主要存放Linux自带组件，     <code>system/build.prop</code> 主要存放的是系统的属性信息。<code>system/fonts</code>存在字体文件目录， <code>/system/framework</code>系统核心文件，框架层。<code>system/lib</code>共享so库。</p>
<p>data目录主要包含了用户的数据信息。</p>
<p>主要包括：<code>/data/app</code>,<code>/data/data</code>,<code>data/system</code>,<code>data/misc</code>主要包含大部分Wifi、VPN信息。</p>
<h4 id="第二章-Android-开发工具"><a href="#第二章-Android-开发工具" class="headerlink" title="第二章 Android 开发工具"></a>第二章 Android 开发工具</h4><p>1、常用的ADB命令</p>
<p><code>adb install  xxx.apk</code>安装应用，<code>adb uninstall xxx.apk</code>卸载应用。<br><code>adb push &lt;local&gt; &lt;remote&gt;</code> copy文件到手机，<local>为本地文件路经，<remote>手机端路径。<code>adb pull &lt;remote&gt; &lt;local&gt;</code>从手机端获取文件。</remote></local></p>
<h4 id="第三章-Android控件架构与自定义控件详解"><a href="#第三章-Android控件架构与自定义控件详解" class="headerlink" title="第三章 Android控件架构与自定义控件详解"></a>第三章 Android控件架构与自定义控件详解</h4><p>1.1、View的控件结构</p>
<p>View控件的树结构：Android整个界面的控件是一个树形结构，即控件树。每棵树的顶部都有一个ViewParent对象，所有的交互事件都由它来同一调度和分配。上层控件负责下层控件的测量和绘制，以及传递交互事件。<code>findViewById</code>就是通过遍历树来查找元素。</p>
<p>1.2、Android界面架构图</p>
<p>每个Acticity都包含一个Window对象，通常由他的子类PhoneWindow来实现。PhoneWindow将一个decorView作为整个应用窗口的根View，DecorView将屏幕分成两部分：TitleView和ContentView。ContentView实际上是一个FrameLayout(id为：android.R.id.content)，里面容纳的就是我们在xml布局文件中定义的布局。decorView里面所有的监听事件都由ActicityManagerServer来接受和回调分发。当程序执行setContentView后，ActivityManagerService会回调onResume()方法，此时系统会将整个DecorView添加到PhoneWindow中。</p>
<p>1.3、onMeasure()测量。</p>
<p>理解MeasureSpec：</p>
<p>MeasureSpec封装了测量的测量模式和测量的大小。它的数值是一个32位的int值，最高两位为测量的模式，低30位是测量的大小。使用位运算提高效率，节约空间。</p>
<ul>
<li>测量规则MeasureSpec：<ul>
<li>EXACTLY  ：view的宽高属性是一个精确的值，layout属性为match_parent时不一定是精确模式</li>
<li>AT_MOST：View的宽高属性为wrap_content，最大值不允许超过父控件指定的尺寸，其大小一般随子View(如果有)或者内容的变化而变化。</li>
<li>UNSPECIFIED：任意大小。在自定义View中才会使用到。</li>
</ul>
</li>
</ul>
<p>View和ViewGroup测量一致，如果需要支持Wrap_content属性需要重写onMeasure()方法。但是ViewGroup的一个职责就是管理子View的显示大小。一般需要遍历子View，并设置它们的大小。</p>
<p>1.4、onDraw()绘制。</p>
<p>重写父类的onDraw()方法，就可以在canvas利用canvas.drawXXX()Api来绘制我们想要的图形，不管多么复杂、精美的控件都可以拆分成一个个小的图像单元，我们要做的就是找到这些图形单元并将其绘制。</p>
<p>书中提到另一样绘制方式，我们创建自己的<code>mCanvas</code>对象，传入onDraw()方法中绘制的<code>bitmap</code>，对这个<code>bitmap</code>进行绘制，然后重绘view，也同样可以改变view的显示效果。代码类似下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawBitmap(bitmap1,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>)</span><br><span class="line">canvas.drawBitmap(bitmap2,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>);</span><br><span class="line">Canvas mCanvas = <span class="keyword">new</span> Canvas(bitmap2);</span><br><span class="line">mCanvas.drawXXX()</span><br></pre></td></tr></table></figure>

<p>View和ViewGroup的绘制：自定义View一般会重写onDraw()方法绘制自己样子。一般来说ViewGroup不需要重写onDraw()方法，如果不设置backgroud，但是会调用dispatchDraw来绘制子View。</p>
<p>1.5、自定义View</p>
<p>通常自定义View包含以下三种情况：</p>
<ul>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写View来实现全新的控件。</li>
</ul>
<p>Canvas对象的各种draw方法的说明：</p>
<p><code>canvas.drawRect()</code>：绘制矩形，需要确定四个点，即left，right，top，buttom。</p>
<p><code>canvas.drawCricle()</code>：绘制圆形，需要确定中心点坐标，半径。即mCircleX，mCircleY，mRadio。</p>
<p><code>canvas.drawArc</code>：绘制弧线，需要确定绘制的矩形，开始角度，当前角度，useCenter，传入false即可。</p>
<p>Paint画笔：</p>
<ul>
<li>指定画笔的颜色<code>paint.setColor()</code></li>
<li>指定画笔的样式<code>paint.setStyle()</code><ul>
<li>FILL，填充整个画笔经过的区域</li>
<li>STROKE，指定画笔只填充边框</li>
<li>FILL_AND_STROKE，这是啥，我不知道。</li>
</ul>
</li>
<li>指定画笔的shader(着色器)：<code>paint.setShader(Shader)</code><ul>
<li>LinearShader：线性颜色渐变着色器。</li>
</ul>
</li>
</ul>
<p>1.6、自定义View/ViewGroup：看代码就好。</p>
<h4 id="第四章-ListView使用技巧"><a href="#第四章-ListView使用技巧" class="headerlink" title="第四章 ListView使用技巧"></a>第四章 ListView使用技巧</h4><p>1.1、设置技巧</p>
<ul>
<li><p>设置ListView每个item的分割线：</p>
<p><code>ndroid:divider=&quot;&quot;@android:color/white&quot;</code><br><code>android:dividerHeight=&quot;10dp&quot;</code><br><code>android:divider = @null</code> （设置分隔线透明）</p>
</li>
<li><p>设置不显示滚动条：android:scrollbars=”none”</p>
</li>
<li><p>取消点击效果：<code>android:listSelector=&quot;@android:color/transparent&quot;</code></p>
</li>
<li><p>取消滑动顶(低)部的半月牙阴影效果：android:overScrollMode=”never”</p>
</li>
<li><p>平滑滚动：</p>
<p><code>listview.setSelection(n);</code> 这个方法类似scrollTo瞬间完成移动。<br><code>listview.smoothScrollBy(distance, duration);</code><br><code>listview.smoothScrollByOffset(offset);</code><br><code>listview.smoothScrollToPosition(index);</code></p>
</li>
<li><p>设置没有数据的ListView显示内容<code>setEmptyView(view)</code></p>
</li>
</ul>
<p>1.2、弹性的ListView</p>
<p>ListView的一个回调方法<code>overScrollBy()</code>，改变maxOverScrollY就可以使ListView具有弹性的功能。</p>
<p>1.3、滚动隐藏和显示toolbar的ListView。</p>
<p>给ListView添加个Toolbar一样大小的headView保证ListView在Toolar下面，然后ListView滚动的时候动态的显示个隐藏Toolbar</p>
<ul>
<li>获取TouchSlop：<code>touchSlop = ViewConfiguration.get(getActivity()).getScaledTouchSlop();</code></li>
<li>获取Toolbar的高度64dp：<code>getResources().getDimension(R.dimen.abc_action_bar_default_height_material)))</code></li>
</ul>
<ul>
<li>触摸监听：<code>onTouchListener</code> 可以得道MotionEnevt对象。</li>
</ul>
<p>1.4、ListView滚动状态监听：</p>
<ul>
<li>滑动监听：<code>onScrollListener</code> 可以获取ListView的滚动状态。</li>
</ul>
<p>1.5、ListView优化在面试中也常被提到，<a href="http://blog.aaapei.com/article/2015/02/facebookxin-wen-ye-listviewyou-hua" target="_blank" rel="noopener">facebookListView的优化。</a></p>
<h4 id="第五章-Android-Scroll分析"><a href="#第五章-Android-Scroll分析" class="headerlink" title="第五章 Android Scroll分析"></a>第五章 Android Scroll分析</h4><p>1.1、实现滑动的基本思想</p>
<p>当View触摸时，记下当前触摸点的坐标。在手指移动时，获取最新坐标，计算出偏移量。通过偏移量修改View的坐标，这样不断的重复，从而实现View的滑动过程。</p>
<blockquote>
<p>实现滑动的方法</p>
</blockquote>
<ul>
<li><p>使用<code>layout()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout(getLeft() + dx, getTop() + dy, getRight() + dx, getBottom() + dy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>offsetLeftAndRight()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offsetLeftAndRight(dx);</span><br><span class="line">offsetTopAndBottom(dy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>LayoutParams。或是使用ViewGroup.MarginLayoutParams</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams)</span><br><span class="line">			getLayoutParams();</span><br><span class="line">layoutParams.leftMargin = dx;</span><br><span class="line">layoutParams.topMargin = dy;</span><br><span class="line">setLayoutParams(layoutParams);</span><br></pre></td></tr></table></figure>
</li>
<li><p>scrollTo和scrollBy。搭配Scroller对象实现平滑滚动。</p>
</li>
</ul>
<p>scrollTo/ScrollBy移动的View的内容区域，View的BackGroud并不会跟随移动。</p>
<p>getScrollX/getScrollY值View内容的滑动距离，View的内容区域在View的边缘右边或下边是这个值为负。</p>
<p>Scroller的startScroll方法实现滚动，同样是移动的View的内容区域，方法本身只是记录了View的移动距离，需要调用View的invalidate()方法并搭配View的computeScroll方法。</p>
<ul>
<li>属性动画</li>
</ul>
<p>1.2、ViewDragHelper</p>
<p>对子View的拖拽进行处理。它主要封装了对View的触摸位置，触摸速度，移动距离等的检测和Scroller,通过接口回调的方式告诉我们;只需要我们指定是否需要移动，移动多少等; 本质是对触摸事件的解析类;</p>
<h4 id="第六章-Android绘图机制与处理技巧"><a href="#第六章-Android绘图机制与处理技巧" class="headerlink" title="第六章 Android绘图机制与处理技巧"></a>第六章 Android绘图机制与处理技巧</h4><p>1.1、2D绘图基础</p>
<p>(1)Canvas对象</p>
<ul>
<li><code>drawPoint</code> ：绘制点</li>
<li><code>drawLine</code> ：绘制直线</li>
<li><code>drawLines</code> ：绘制多条直线</li>
<li><code>drawRect</code> ：绘制矩形</li>
<li><code>drawRoundRect(left,top,right,buttom,radiusX,radiusY,paint</code>)` ：绘制圆角矩形</li>
<li><code>drawCircle</code>：绘制圆形</li>
<li><code>drawArc()</code> ：绘制弧型</li>
<li><code>drawOval</code> ：绘制椭圆</li>
<li><code>drawText</code> ：绘制文本</li>
<li><code>drawPosText</code> ：在指定位置绘制文本</li>
<li><code>drawPath</code> ：绘制path路径</li>
</ul>
<p>(2)Paint对象</p>
<ul>
<li><code>setAntiAlias</code> ：设置画笔的锯齿效果</li>
</ul>
<ul>
<li><code>setColor</code> ：设置画笔的颜色</li>
</ul>
<ul>
<li><code>setARGB</code> ：设置画笔的A、R、G、B值</li>
</ul>
<ul>
<li><code>setAlpha</code> ：设置画笔的透明度值</li>
</ul>
<ul>
<li><code>setTextSize</code> ：设置字体大小</li>
</ul>
<ul>
<li><code>setStyle</code> ：设置画笔的效果（空心STROKE或者实心FILL）</li>
</ul>
<ul>
<li><code>setStrokeWidth</code> ：设置画笔的宽度</li>
</ul>
<p>1.2、Android   Xml绘图</p>
<ul>
<li>bitmap：在drawable文件夹下定义bitmap，可以直接转化成bitmap在程序中使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;bitmap</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:src=<span class="string">"@[package:]drawable/drawable_resource"</span></span><br><span class="line">    android:antialias=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:dither=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:filter=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:gravity=[<span class="string">"top"</span> | <span class="string">"bottom"</span> | <span class="string">"left"</span> | <span class="string">"right"</span> | <span class="string">"center_vertical"</span> |</span><br><span class="line">                      <span class="string">"fill_vertical"</span> | <span class="string">"center_horizontal"</span> | <span class="string">"fill_horizontal"</span> |</span><br><span class="line">                      <span class="string">"center"</span> | <span class="string">"fill"</span> | <span class="string">"clip_vertical"</span> | <span class="string">"clip_horizontal"</span>]</span><br><span class="line">    android:tileMode=[<span class="string">"disabled"</span> | <span class="string">"clamp"</span> | <span class="string">"repeat"</span> | <span class="string">"mirror"</span>] /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>shape：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;shape    </span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>    </span><br><span class="line">    android:shape=[<span class="string">"rectangle"</span> | <span class="string">"oval"</span> | <span class="string">"line"</span> | <span class="string">"ring"</span>] &gt;    </span><br><span class="line">    &lt;corners   <span class="comment">//当shape为rectangle时使用</span></span><br><span class="line">        android:radius=<span class="string">"integer"</span> <span class="comment">//半径值会被后面的单个半径属性覆盖，默认为1dp</span></span><br><span class="line">        android:topLeftRadius=<span class="string">"integer"</span>        </span><br><span class="line">        android:topRightRadius=<span class="string">"integer"</span>        </span><br><span class="line">        android:bottomLeftRadius=<span class="string">"integer"</span>        </span><br><span class="line">        android:bottomRightRadius=<span class="string">"integer"</span> /&gt;    </span><br><span class="line">    &lt;gradient       <span class="comment">//渐变</span></span><br><span class="line">        android:angle=<span class="string">"integer"</span>        </span><br><span class="line">        android:centerX=<span class="string">"integer"</span>        </span><br><span class="line">        android:centerY=<span class="string">"integer"</span>        </span><br><span class="line">        android:centerColor=<span class="string">"integer"</span>        </span><br><span class="line">        android:endColor=<span class="string">"color"</span>        </span><br><span class="line">        android:gradientRadius=<span class="string">"integer"</span>        </span><br><span class="line">        android:startColor=<span class="string">"color"</span>        </span><br><span class="line">        android:type=[<span class="string">"linear"</span> | <span class="string">"radial"</span> | <span class="string">"sweep"</span>]        </span><br><span class="line">        android:useLevel=[<span class="string">"true"</span> | <span class="string">"false"</span>] /&gt;    </span><br><span class="line">    &lt;padding        <span class="comment">//内边距</span></span><br><span class="line">        android:left=<span class="string">"integer"</span>        </span><br><span class="line">        android:top=<span class="string">"integer"</span>        </span><br><span class="line">        android:right=<span class="string">"integer"</span>        </span><br><span class="line">        android:bottom=<span class="string">"integer"</span> /&gt;    </span><br><span class="line">    &lt;size           <span class="comment">//指定大小，一般用在imageview配合scaleType属性使用</span></span><br><span class="line">        android:width=<span class="string">"integer"</span>        </span><br><span class="line">        android:height=<span class="string">"integer"</span> /&gt;    </span><br><span class="line">    &lt;solid          <span class="comment">//填充颜色</span></span><br><span class="line">        android:color=<span class="string">"color"</span> /&gt;    </span><br><span class="line">   	&lt;stroke         <span class="comment">//边框</span></span><br><span class="line">      	android:width=<span class="string">"integer"</span>        </span><br><span class="line">        android:color=<span class="string">"color"</span>        </span><br><span class="line">        android:dashWidth=<span class="string">"integer"</span>        </span><br><span class="line">        android:dashGap=<span class="string">"integer"</span> /&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Layer</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;layer-list xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@[package:]drawable/drawable_resource"</span> /&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@[package:]drawable/drawable_resource"</span> /&gt;</span><br><span class="line">    ......</span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>selector</li>
</ul>
<p>selector的用法很多，一般是定义控件在不同状态下的显示形态，可以是图片drawable，也可以是形状shape，还可以只是颜色color！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span> ?&gt;</span><br><span class="line">&lt;selector xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;!-- 默认时的背景图片--&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/pic1"</span>/&gt;</span><br><span class="line">    &lt;!-- 没有焦点时的背景图片 --&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/pic1"</span> android:state_window_focused=<span class="string">"false"</span>/&gt;</span><br><span class="line">    &lt;!-- 非触摸模式下获得焦点并单击时的背景图片 --&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/pic2"</span> android:state_focused=<span class="string">"true"</span> android:state_pressed=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;!-- 触摸模式下单击时的背景图片--&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/pic3"</span> android:state_focused=<span class="string">"false"</span> android:state_pressed=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;!--选中时的图片背景--&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/pic4"</span> android:state_selected=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;!--获得焦点时的图片背景--&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">"@drawable/pic5"</span> android:state_focused=<span class="string">"true"</span>/&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>

<p>selector可以用来指定不同状态下文本的颜色，例如按钮上的文本的颜色</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;selector xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;item android:color=<span class="string">"#999"</span> android:state_selected=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;item android:color=<span class="string">"#666"</span> android:state_focused=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;item android:color=<span class="string">"#333"</span> android:state_pressed=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;item android:color=<span class="string">"#000"</span>/&gt;</span><br><span class="line">&lt;/selector&gt;</span><br></pre></td></tr></table></figure>

<p>结合这篇博文<a href="http://blog.csdn.net/brokge/article/details/9713041" target="_blank" rel="noopener">Android开发：shape和selector和layer-list</a>以及博主的实现的<a href="http://blog.csdn.net/brokge/article/details/41318117" target="_blank" rel="noopener">圆角镂空按钮</a>例子(综合使用了Shape、Layer和Selector实现了圆角镂空按钮)一起看还是挺不错的。</p>
<p>1.3、Android 绘图技巧</p>
<ul>
<li>Canvas画布</li>
</ul>
<p><code>save</code>：保存画布，将之前绘制的内容保存起来，让后续的绘制操作像是在一个新的画布上绘制。<br><code>restore</code>：合并画布，将save方法之后绘制的内容与之前绘制的内容合并起来；<br><code>translate</code>：移动画布，其实是画布所在的坐标系的移动；调用之前先save较好。<br><code>rotate</code>：旋转画布，其实是画布所在的坐标系的旋转。</p>
<ul>
<li>Layer 图层</li>
</ul>
<p>在Android中图层是基于栈的结构来管理的，通过调用<code>saveLayer()</code>、<code>saveLayerAlpha()</code>方法来创建图层和创建一个透明的图层，即入栈创建一个图层栈，使用<code>restore</code>、<code>restoreToCount</code>方法合并一个或多个图层，即出栈，将图层上的内容合并到canvas上。入栈的时候，后面所有的操作都发生在这个图层上，而出栈的时候则会把图像绘制在上层Canvas上。</p>
<p>1.4、Android图像处理：色彩特效、图形特效、画笔特效。</p>
<p>1.5、SurfaceView</p>
<p>SurfaceView是View的子类。View的onDraw方法运行在主线程，同时View的绘制每隔16m绘制一次，如果在16m的时间内不能完成界面的绘制，那么在视觉上就会造成卡顿，通常在Log中出现The application may be doing must work on main thread就是View的绘制阻塞了主线程。而SurfaceView的绘制运行在子线程，他很好的代替了View在不断刷新状态下的不足。</p>
<p>SurfaceView适用于比较频繁刷新的界面，并且实现了双缓冲的机制。</p>
<ul>
<li>使用</li>
</ul>
<p>使用SurfaceView我们通常实现两个接口，SurfaceHolder.Callback和Runnable。</p>
<p>SurfaceHolder：管理SurfaceView的声明周期（回调方法）和获取canvas对象进行绘制。</p>
<p>通过<code>lockCanvas</code>方法获取Canvas对象进行绘制，并通过<code>unlockCanvasAndPost</code>方法对画布内容进行提交。<br>需要注意的是每次调用lockCanvas拿到的Canvas都是同一个Canvas对象，所以之前的操作都会保留，如果需要擦除，可以在绘制之前调用drawColor方法来进行清屏。</p>
<h4 id="第七章-Android动画机制与使用技巧"><a href="#第七章-Android动画机制与使用技巧" class="headerlink" title="第七章 Android动画机制与使用技巧"></a>第七章 Android动画机制与使用技巧</h4><p>1.1、View动画 （视图动画）<br>视图动画(Animation)框架定义了透明度(AlphaAnimation)、旋转(RotateAnimation)、缩放(ScaleAnimation)和位移(TranslateAnimation)几种常见的动画，控制的是整个View，所以视图动画的缺陷就在于当某个元素发生视图动画后，其响应事件的位置还依然停留在原来的地方！</p>
<blockquote>
<p>实现原理是每次绘制视图时View所在的ViewGroup中的drawChild方法获取该View的Animation的Transformation值，然后调用canvas.concat(transformationToApply.getMatrix())，通过矩阵运算完成动画帧。如果动画没有完成，就继续调用invalidate方法，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>
</blockquote>
<ul>
<li>动画集合(AnimationSet)：将多个视图动画组合起来</li>
</ul>
<ul>
<li>动画监听器(AnimationListener)：提供动画的监听回调方法</li>
</ul>
<p>1.2、属性动画</p>
<p>Android 3.0之后添加了属性动画(Animator)框架，其中核心类ObjectAnimator能够自动驱动，在不影响动画效果的情况下减少CPU资源消耗。</p>
<p><strong>ObjectAnimator</strong><br>创建ObjectAnimator只需通过它的静态工厂方法直接返回一个ObjectAnimator对象，参数包括view对象，以及view的属性名字，这个属性必须要有get/set方法，因为ObjectAnimator内部会通过反射机制来修改属性值。常用的可以直接使用属性动画的属性包括：<br>(1)<code>translationX</code>和<code>translationY</code>：控制view从它布局容器左上角坐标偏移的位置；<br>(2)<code>rotation</code>、<code>rotationX</code>和<code>rotationY</code>：控制view围绕支点进行2D和3D旋转；<br>(3)<code>scaleX</code>和<code>scaleY</code>：控制view围绕着它的支点进行2D缩放；<br>(4)<code>pivotX</code>和<code>pivotY</code>：控制支点位置，围绕这个支点进行旋转和缩放处理。默认情况下，支点是view的中心点；<br>(5)<code>x</code>和<code>y</code>：控制view在它的容器中的最终位置，它是最初的左上角坐标和translationX、translationY的累计和；<br>(6)<code>alpha</code>：控制透明度，默认是1（不透明）。</p>
<p>ObjectAnimator的常见使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, <span class="string">"translationX"</span>, <span class="number">300</span>);</span><br><span class="line">animator.setDuration(<span class="number">1000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p>属性动画集合AnimatorSet：控制多个动画的协同工作方式，常用方法<code>animatorSet.play().with().before().after()</code>、<code>playTogether</code>、<code>playSequentially</code>等方法来精确控制动画播放顺序。使用<code>PropertyValueHolder</code>也可以实现简单的动画集合效果。</p>
<p><strong>动画监听器</strong>：监听动画事件可以使用<code>AnimatorListener</code>或者简易的适配器<code>AnimatorListenerAdapter</code></p>
<p><strong>如果一个属性没有get/set方法怎么办？</strong><br>(1)自定义包装类，间接地给属性提供get/set方法，下面就是一个包装类的例子，为width属性提供了get/set方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> View mView;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapperView</span><span class="params">(View mView)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mView = mView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mView.getLayoutParams().width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">        mView.getLayoutParams().width = width;</span><br><span class="line">        mView.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)使用<code>ValueAnimator</code><br>ObjectAnimator就是继承自ValueAnimator的，它是属性动画的核心，ValueAnimator不提供任何动画效果，它就是一个数值产生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程，控制的方式是使用<code>AnimatorUpdateListener</code>来监听数值的变换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator animator = ValueAnimator.ofFloat(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">animator.setTarget(view);</span><br><span class="line">animator.setDuration(<span class="number">1000</span>);</span><br><span class="line">animator.start();</span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        Float value = (Float) animation.getAnimatedValue();</span><br><span class="line">        <span class="comment">//do the animation!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>在XML中使用属性动画</strong><br>下面是一个简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;objectAnimator xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:duration=<span class="string">"4000"</span></span><br><span class="line">    android:propertyName=<span class="string">"rotation"</span></span><br><span class="line">    android:valueFrom=<span class="string">"0"</span></span><br><span class="line">    android:valueTo=<span class="string">"360"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>在代码中使用方式如下： <strong>[注：测试该代码的时候，上面的xml定义应该放在res的animator目录下，放在anim目录下不行]</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = AnimatorInflater.loadAnimator(<span class="keyword">this</span>, R.animator.animator_rotation);</span><br><span class="line">animator.setTarget(view);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p><strong>View的animate方法</strong><br>Android 3.0之后View新增了animate方法直接驱动属性动画，它其实是属性动画的一种简写方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">imageView.animate().alpha(<span class="number">0</span>).y(<span class="number">100</span>).setDuration(<span class="number">1000</span>)</span><br><span class="line">        .setListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>3.布局动画</p>
<p>布局动画是作用在ViewGroup上的，给ViewGroup添加view时添加动画过渡效果。<br>(1)简易方式（但是没有什么效果）：在xml中添加如下属性 <code>android:animateLayoutChanges=&quot;true</code><br>(2)通过LayoutAnimationController来自定义子view的过渡效果，下面是一个常见的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout linearLayout = (LinearLayout) findViewById(R.id.ll);</span><br><span class="line">ScaleAnimation scaleAnimation = <span class="keyword">new</span> ScaleAnimation(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">scaleAnimation.setDuration(<span class="number">2000</span>);</span><br><span class="line">LayoutAnimationController controller = <span class="keyword">new</span> LayoutAnimationController(scaleAnimation, <span class="number">0.5f</span>);</span><br><span class="line">controller.setOrder(LayoutAnimationController.ORDER_NORMAL);<span class="comment">//NORMAL 顺序 RANDOM 随机 REVERSE 反序</span></span><br><span class="line">linearLayout.setLayoutAnimation(controller);</span><br></pre></td></tr></table></figure>

<p>4.自定义动画<br>创建自定义动画就是要实现它的<code>applyTransformation</code>的逻辑，不过通常还需要覆盖父类的<code>initialize</code>方法来实现初始化工作。<br>下面是一个模拟电视机关闭的动画，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTV</span> <span class="keyword">extends</span> <span class="title">Animation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCenterWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCenterHeight;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> parentWidth, <span class="keyword">int</span> parentHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize(width, height, parentWidth, parentHeight);</span><br><span class="line">        setDuration(<span class="number">1000</span>);<span class="comment">// 设置默认时长</span></span><br><span class="line">        setFillAfter(<span class="keyword">true</span>);<span class="comment">// 动画结束后保留状态</span></span><br><span class="line">        setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());<span class="comment">// 设置默认插值器</span></span><br><span class="line">        mCenterWidth = width / <span class="number">2</span>;</span><br><span class="line">        mCenterHeight = height / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Matrix matrix = t.getMatrix();</span><br><span class="line">        matrix.preScale(<span class="number">1</span>, <span class="number">1</span> - interpolatedTime, mCenterWidth, mCenterHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyTransformation方法的第一个参数interpolatedTime是插值器的时间因子，取值在0到1之间；第二个参数Transformation是矩阵的封装类，一般使用它来获得当前的矩阵Matrix对象，然后对矩阵进行操作，就可以实现动画效果了。</p>
<p><strong>如何实现3D动画效果呢？</strong><br>使用<code>android.graphics.Camera</code>中的Camera类，它封装了OpenGL的3D动画。可以把Camera想象成一个真实的摄像机，当物体固定在某处时，只要移动摄像机就能拍摄到具有立体感的图像，因此通过它可以实现各种3D效果。<br>下面是一个3D动画效果的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAnim</span> <span class="keyword">extends</span> <span class="title">Animation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCenterWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCenterHeight;</span><br><span class="line">    <span class="keyword">private</span> Camera mCamera = <span class="keyword">new</span> Camera();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mRotateY = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> parentWidth, <span class="keyword">int</span> parentHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize(width, height, parentWidth, parentHeight);</span><br><span class="line">        setDuration(<span class="number">2000</span>);<span class="comment">// 设置默认时长</span></span><br><span class="line">        setFillAfter(<span class="keyword">true</span>);<span class="comment">// 动画结束后保留状态</span></span><br><span class="line">        setInterpolator(<span class="keyword">new</span> BounceInterpolator());<span class="comment">// 设置默认插值器</span></span><br><span class="line">        mCenterWidth = width / <span class="number">2</span>;</span><br><span class="line">        mCenterHeight = height / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露接口-设置旋转角度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRotateY</span><span class="params">(<span class="keyword">float</span> rotateY)</span> </span>&#123;</span><br><span class="line">        mRotateY = rotateY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">( <span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Matrix matrix = t.getMatrix();</span><br><span class="line">        mCamera.save();</span><br><span class="line">        mCamera.rotateY(mRotateY * interpolatedTime);<span class="comment">// 使用Camera设置旋转的角度</span></span><br><span class="line">        mCamera.getMatrix(matrix);<span class="comment">// 将旋转变换作用到matrix上</span></span><br><span class="line">        mCamera.restore();</span><br><span class="line">        <span class="comment">// 通过pre方法设置矩阵作用前的偏移量来改变旋转中心</span></span><br><span class="line">        matrix.preTranslate(mCenterWidth, mCenterHeight);</span><br><span class="line">        matrix.postTranslate(-mCenterWidth, -mCenterHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第八章-activity与activity调用栈分析"><a href="#第八章-activity与activity调用栈分析" class="headerlink" title="第八章 activity与activity调用栈分析"></a>第八章 activity与activity调用栈分析</h4><p>1.1、Activity生命周期注意点：</p>
<ul>
<li>启动一个新的Activity，两个activity的生命周期<ul>
<li>启动后调用了<code>finish()</code>方法，先调用旧Activity的onPause方法，然后调用新的Activity的onCreate-&gt;onStart-&gt;onResume方法，最后调用旧Activity的onStop-&gt;onDestory方法。</li>
<li>没有调用<code>finish()</code>方法，那么旧Activity会调用onPause-&gt;onSaveInstanceState-&gt;onStop方法，onDestory方法不会被调用。</li>
<li>如果新的Activity为透明或则对话框的格式，那么旧<code>onPause</code>、<code>onSaveInstanceState</code></li>
</ul>
</li>
</ul>
<ul>
<li>如果应用长时间处于stopped状态并且此时系统内存极为紧张的时候，系统就会回收Activity，此时系统在回收之前会回调<code>onSaveInstanceState</code>方法来保存应用的数据Bundle。当该Activity重新创建的时候，保存的Bundle数据就会传递到<code>onRestoreInstanceState</code>方法和<code>onCreate</code>方法中，这就是<code>onCreate</code>方法中<code>Bundle savedInstanceState</code>参数的来源。</li>
<li>用户点击back键不会调用<code>onSavaInstancestate()</code>方法，而点击Home键则会调用<code>onSavaInstanceState</code>方法，却别在于是不是应用主动的行为去停止当前的Activity。</li>
</ul>
<ul>
<li><strong>onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的。</strong>onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据。onRestoreInstanceState被调用的前提是，activity“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity，这种情况下activity一般不会因为内存的原因被系统销毁，故activity的onRestoreInstanceState方法不会被执行。</li>
</ul>
<p>1.2、Activity的任务栈</p>
<p>应用内的Activity是被任务栈Task来管理的，一个Task中的Activity可以来自不同的应用，同一个应用的Activity也可能不在同一个Task中。默认情况下，任务栈依据栈的后进先出原则管理Activity，但是Activity可以设置一些“特权”打破默认的规则，主要是通过在AndroidManifest文件中的属性<code>android:launchMode</code>或者通过Intent的flag来设置。</p>
<p>合理的设置设置Acticity的启动模式会让程序的运行更加有效率用户体验更好。</p>
<p><strong>standard</strong>：默认的启动模式，该模式下会生成一个新的Activity，同时将该Activity实例压入到栈中（不管该Activity是否已经存在在Task栈中，都是采用new操作）。例如： 栈中顺序是A B C D ，此时D通过Intent跳转到A，那么栈中结构就变成 A B C D A，点击返回按钮的 显示顺序是 D C B A，依次摧毁。</p>
<p><strong>singleTop</strong>：在singleTop模式下，如果当前Activity D位于栈顶，此时通过Intent跳转到它本身的Activity（即D），那么不会重新创建一个新的D实例（走<code>onNewIntent()</code>），所以栈中的结构依旧为A B C D，如果跳转到B，那么由于B不处于栈顶，所以会新建一个B实例并压入到栈中，结构就变成了A B C D B。应用实例：三条推送，点进去都是一个activity。</p>
<p><strong>singleTask</strong>：在singleTask模式下，Task栈中只能有一个对应Activity的实例。例如：现在栈的结构为A B C D，此时D通过Intent跳转到B（走<code>onNewIntent()</code>），则栈的结构变成了：A B。其中的C和D被栈弹出销毁了，也就是说位于B之上的实例都被销毁了。如果其他程序通过singleTask的模式来启动该Activity，那么他会创建一个新的任务栈（类是singleInStance），但是如果启动的acticity已经在后台的任务栈中了，那么这个任务栈也会一起被唤到前台。案例：1.通常应用于首页，首页肯定得在栈底部，也只能在栈底部。2.退出整个应用，将主Activity设置为SingTask的模式，然后在要退出的activity中转到主Activity，从而将主Activity上的所有Activity中全部清楚，然后重新<code>onNewIntent()</code>方法，在方法的最后加上一句<code>finish()</code>。    </p>
<p><strong>singleInstance</strong>：singleInstance模式下会将打开的Activity压入一个新建的任务栈中。例如：Task栈1中结构为：A B C，C通过Intent跳转到了D（D的启动模式为singleInstance），那么则会新建一个Task 栈2，栈1中结构依旧为A B C，栈2中结构为D，此时屏幕中显示D，之后D通过Intent跳转到D，栈2中不会压入新的D，所以2个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的启动模式在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C，此时点击返回按钮，还是在C，栈1的结构变为A B C，而不会回到D。</p>
<p>3.Intent Flag启动模式`</p>
<p>(1)<code>Intent.FLAG_ACTIVITY_NEW_TASK</code>：使用一个新的task来启动Activity，一般用在service中启动Activity的场景，因为service中并不存在Activity栈。<br>(2)<code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>：类似<code>andoid:launchMode=&quot;singleTop&quot;</code><br>(3)<code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>：类似<code>andoid:launchMode=&quot;singleTask&quot;</code><br>(4)<code>Intent.FLAG_ACTIVITY_NO_HISTORY</code>：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在task栈中。例如A B，在B中以这种模式启动C，C再启动D，则当前的task栈变成A B D。</p>
<p>4.清空任务栈<br>(1)<code>clearTaskOnLaunch</code>：每次返回该Activity时，都将该Activity之上的所有Activity都清除。通过这个属性可以让task每次在初始化的时候都只有这一个Activity。<br>(2)<code>finishOnTaskLaunch</code>：clearTaskOnLaunch作用在别的Activity身上，而finishOnTaskLaunch作用在自己身上。通过这个属性，当离开这个Activity所在的task，那么当用户再返回时，该Activity就会被finish掉。<br>(3)<code>alwaysRetainTaskState</code>：如果将Activity的这个属性设置为true，那么该Activity所在的task将不接受任何清理命令，一直保持当前task状态，相当于给了task一道”免死金牌”。</p>
<h4 id="第九章-Android系统信息与安全机制"><a href="#第九章-Android系统信息与安全机制" class="headerlink" title="第九章 Android系统信息与安全机制"></a>第九章 Android系统信息与安全机制</h4><p>1.获取系统信息：<code>android.os.Build</code>和<code>SystemProperty</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Build</span></span><br><span class="line">String board = Build.BOARD;     <span class="comment">//主板</span></span><br><span class="line">String brand = Build.BRAND;		<span class="comment">//系统定制商</span></span><br><span class="line">String supported_abis = Build.SUPPORTED_ABIS[<span class="number">0</span>];  <span class="comment">//CPU指令集</span></span><br><span class="line">String device = Build.DEVICE;   <span class="comment">//设备参数</span></span><br><span class="line">String display = Build.DISPLAY;	<span class="comment">//显示屏参数</span></span><br><span class="line">String fingerprint = Build.FINGERPRINT;  <span class="comment">//唯一编号</span></span><br><span class="line">String serial = Build.SERIAL;   <span class="comment">//硬件序列号</span></span><br><span class="line">String id = Build.ID;			<span class="comment">//修订版本列表</span></span><br><span class="line">String manufacturer = Build.MANUFACTURER;  <span class="comment">//硬件制造商</span></span><br><span class="line">String model = Build.MODEL;    <span class="comment">//版本</span></span><br><span class="line">String hardware = Build.HARDWARE;  <span class="comment">//硬件名</span></span><br><span class="line">String product = Build.PRODUCT;  <span class="comment">//手机产品名</span></span><br><span class="line">String tags = Build.TAGS;		<span class="comment">//描述build的标签</span></span><br><span class="line">String type = Build.TYPE;	   <span class="comment">//Builder类型</span></span><br><span class="line">String codename = Build.VERSION.CODENAME;  <span class="comment">//当前开发代号</span></span><br><span class="line">String incremental = Build.VERSION.INCREMENTAL;  <span class="comment">//源码控制版本号</span></span><br><span class="line">String release = Build.VERSION.RELEASE;  <span class="comment">//版本字符串</span></span><br><span class="line">String sdk_int = <span class="string">""</span> + Build.VERSION.SDK_INT; <span class="comment">//版本号</span></span><br><span class="line">String host = Build.HOST;  <span class="comment">//host值</span></span><br><span class="line">String user = Build.USER;  <span class="comment">//user名</span></span><br><span class="line">String time = <span class="string">""</span> + Build.TIME; <span class="comment">//编译时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SystemProperty</span></span><br><span class="line">String os_version = System.getProperty(<span class="string">"os.version"</span>);    <span class="comment">//os版本</span></span><br><span class="line">String os_name = System.getProperty(<span class="string">"os.name"</span>);			<span class="comment">//os名称</span></span><br><span class="line">String os_arch = System.getProperty(<span class="string">"os.arch"</span>);			<span class="comment">//os架构</span></span><br><span class="line">String user_home = System.getProperty(<span class="string">"user.home"</span>);		<span class="comment">//home属性</span></span><br><span class="line">String user_name = System.getProperty(<span class="string">"user.name"</span>);		<span class="comment">//name属性</span></span><br><span class="line">String user_dir = System.getProperty(<span class="string">"user.dir"</span>);		<span class="comment">//dir属性</span></span><br><span class="line">String user_timezone = System.getProperty(<span class="string">"user.timezone"</span>);<span class="comment">//时区</span></span><br><span class="line">String path_separator = System.getProperty(<span class="string">"path.separator"</span>);<span class="comment">//路径分隔符</span></span><br><span class="line">String line_separator = System.getProperty(<span class="string">"line.separator"</span>);<span class="comment">//行分隔符</span></span><br><span class="line">String file_separator = System.getProperty(<span class="string">"file.separator"</span>);<span class="comment">//文件分隔符</span></span><br><span class="line">String java_vendor_url = System.getProperty(<span class="string">"java.vendor.url"</span>);<span class="comment">//java verder URL属性</span></span><br><span class="line">String java_class_path = System.getProperty(<span class="string">"java.class.path"</span>);<span class="comment">//java class路径</span></span><br><span class="line">String java_class_version = System.getProperty(<span class="string">"java.class.version"</span>);<span class="comment">//java class版本</span></span><br><span class="line">String java_vendor = System.getProperty(<span class="string">"java.vendor"</span>);<span class="comment">//java vender版本</span></span><br><span class="line">String java_version = System.getProperty(<span class="string">"java.version"</span>);<span class="comment">//java版本</span></span><br><span class="line">String java_home = System.getProperty(<span class="string">"java_home"</span>); <span class="comment">//java home属性</span></span><br></pre></td></tr></table></figure>

<p>2.Apk应用信息：<code>PackageManager</code>和<code>ActivityManager</code></p>
<p>在AndroidManifest文件中，Activity的信息是通过<code>ActivityInfo</code>类来封装的；整个Manifest文件中节点的信息是通过<code>PackageInfo</code>类来进行封装的；此外还非有<code>ServiceInfo</code>、<code>ApplicationInfo</code>、<code>ResolveInfo</code>等。其中<code>ResolveInfo</code>封装的是包含信息的上一级信息，所以它可以返回ActivityInfo、ServiceInfo等包含的信息，它经常用来帮助我们找到那些包含特定Intent条件的信息，如带分享功能、播放功能的应用。</p>
<p>PackageManager侧重于获取应用的包信息，而ActivityManager侧重于获取运行的应用程序的信息。<br>PackageManager常用的方法：<br><code>getPackageManger</code>、<code>getApplicationInfo</code>、<code>getApplicationIcon</code>、<code>getInstalledApplications</code>、<code>getInstalledPackages</code>、<code>queryIntentActivities</code>、<code>queryIntentServices</code>、<code>resolveActivity</code>、<code>resolveService</code>等。<br>ActivityManager封装了不少对象，每个对象都保存着一些重要信息。<br><code>ActivityManager.MemoryInfo</code>：关于系统内存的信息，例如<code>availMem</code>(系统可用内存)、<code>totalMem</code>(总内存)等；<br><code>Debug.MemoryInfo</code>：该MemoryInfo主要用于统计进程下的内存信息；<br><code>RunningAppProceeInfo</code>：运行进程的信息，存储的是与进程相关的信息，例如<code>processName</code>、<code>pid</code>、<code>uid</code>等；<br><code>RunningServiceInfo</code>：运行服务的信息，存储的是服务进程的信息，例如<code>activeSince</code>(第一次被激活时间)等。</p>
<p>1.3、packages.xml文件(位于<code>/data/system</code>目录下)<br>在系统初始化的时候，PackageManager的底层实现类PackageManagerService会去扫描系统中的一些特定的目录，并解析其中的apk文件，最后把它获得的应用信息保存到packages.xml文件中，当系统中的应用安装、删除或者升级时，它也会被更新。</p>
<p>1.4、Android安全机制<br>五道防线：<br>(1)代码安全机制——代码混淆proguard<br>(2)应用接入权限机制——AndroidManifest文件权限声明、权限检查机制<br>系统检查操作者权限的顺序：首先，判断permission名称，如果为空则直接返回PERMISSION_DENIED;其次，判断Uid，如果uid为0或者为System Service的uid，不做权限控制，如果uid与参数中的请求uid不同，那么返回PERMISSION_DENIED；最后，通过调用PackageManagerService.checkUidPermission方法判断该uid是否具有相应的权限，该方法会去xml的权限列表和系统级的platform.xml中进行查找。<br>(3)应用签名机制——数字证书：系统不会安装没有签名的app，只有拥有相同数字签名的app才会在升级时被认为是同一个app<br>(4)Linux内核层安全机制——Uid、访问权限控制<br>(5)Android虚拟机沙箱机制——沙箱隔离：每个app运行在单独的虚拟机中，与其他应用完全隔离</p>
<p><strong>apk反编译</strong><br>使用apktool、dex2jar、jd-gui三个工具反编译查看应用源码</p>
<p><strong>apk加密</strong><br>proguard不仅可以用来混淆代码（用无意义的字母来重命名类、方法和属性等），还可以删除无用的类、字段、方法和属性，以及删除无用的注释，最大限度地优化字节码文件。<br>下面是常见的proguard配置，其中<code>minifyEnabled</code>属性控制是否启动proguard；<code>proguardFiles</code>属性用于配置混淆文件，它分为两部分，一个是系统默认的混淆文件，它位于<code>/tools/proguard/proguard-android.txt</code>；另一个是自定义的混淆文件，可以在项目的app文件夹下找到该文件，在该文件中定义引入的第三方依赖包的混淆规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="keyword">false</span></span><br><span class="line">        <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, </span></span><br><span class="line"><span class="function">          'proguard-rules.pro'</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="第十章-Android性能优化"><a href="#第十章-Android性能优化" class="headerlink" title="第十章 Android性能优化"></a>第十章 Android性能优化</h4><p>1.1、布局优化</p>
<p>人眼感觉的流畅需要画面的帧数达到每秒40帧到60帧，那么差不多每16ms（1000/16）系统就要对UI进行渲染和重绘。如果在16m内不能完成绘制，那么就会就等待下次VSYNC信息发出界面重绘，这样就造成了界面的丢帧现象，即卡顿的原因。</p>
<p>(1)、AndroidUI渲染机制：android系统提供了检测UI渲染时间的工具，开发者选项-&gt;Profile GPU rendering(GPU呈现模式分析)-&gt;On screen as bars。中间的绿色横线代表VSYNC时间16ms，需要尽量将所有条形图都控制在这条绿线之下。</p>
<p>(2)、避免过度绘制：过度绘制（Overdraw）也是很浪费CPU/GPU资源的，系统也提供了检测工具Debug GPU Overdraw (调试界面过度绘制)，来查看界面overdraw的情况。该工具会使用不同的颜色绘制屏幕，来指示overdraw发生在哪里以及程度如何，其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">没有颜色： 意味着没有overdraw。像素只画了一次。</span><br><span class="line">蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的、</span><br><span class="line">绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。</span><br><span class="line">浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。</span><br><span class="line">暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。</span><br></pre></td></tr></table></figure>

<p>(3)、优化布局层级，在Android中系统对View的测量，布局，绘制都是通过遍历View树操作的。因此，View树的高度不宜太高。Google在文档中建议View树的高度不宜超过10层。</p>
<p>(4)、避免嵌套过多无用布局：</p>
<ul>
<li>使用”<include>“标签重用layout</include></li>
<li>使用”<ViewStub>“实现view的延迟加载</ViewStub></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ViewStub mViewStub = findViewById(R.id.not_often_use);</span><br><span class="line">mViewStub.setVisible(View.VISIBLE);</span><br><span class="line"><span class="comment">//inflate </span></span><br><span class="line">View inflateView = mViewStub.inflate();</span><br><span class="line">inflateView.findViewById();</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>ViewStub是一个非常轻量级的组件，它不仅不可见，而且大小为0。</p>
<p>ViewStub和View.GONE有啥区别？</p>
<p>它们的共同点是初始时都不会显示，但是前者只会在显示时才去渲染整个布局，而后者在初始化布局树的时候就已经添加到布局树上了，相比之下前者的布局具有更高的效率。</p>
<p>(5)、Hierarchy Viewer：查看视图树的工具，可以帮助我们找到布局冗余，优化布局。</p>
<p>1.2、内存优化</p>
<p>由于Android的沙箱机制，每个应用所分配的内存大小是有限制的，内存太低就会触发LMK - (Low Memory killer)机制。</p>
<p>通常情况下我们所说的内存是指手机的RAM，它包括以下几部分：</p>
<ul>
<li>寄存器(Register)：速度最快的场所。寄存器处于CPU内部，在程序中无法控制；</li>
</ul>
<ul>
<li>栈(Stack)：存放基本数据类型和对象的引用；</li>
</ul>
<ul>
<li>堆(Heap)：存放new出来的对象和数组，由虚拟机GC来管理；在程序获取堆内存的大小。</li>
</ul>
<ul>
<li>静态存储区域(static field)：在固定的位置存放应用程序运行时一直存在的数据，Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量，如静态的数据变量；</li>
</ul>
<ul>
<li>常量池(constant pool)：虚拟机必须为每个被装在的类型维护一个常量池，常量池就是这个类所用的常量的一个有序集合，包括直接常量（基本类型、string）和对其他类型、字段和方法的符号引用。</li>
</ul>
<p>栈中的变量作用域结束后，这部分空间就会马上被用作新的控件进行分配。</p>
<p>堆中的对象作用域结束后，这部分内存不会马上被回收，而是等待系统GC来回收，堆内存的大小随着手机的不断发展而变大，可以通过以下代码回去手机堆内存的大小，所谓的内存分析就是对堆内存中的内存状态进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line"><span class="keyword">int</span> heapSize = am.getLargeMemoryClass();</span><br></pre></td></tr></table></figure>

<p>1.3、内存优化实例<br>(1)Bitmap优化</p>
<ul>
<li>使用适当分辨率和大小的图片，通过Options对象图片进行压缩。</li>
</ul>
<ul>
<li>及时回收内存：从Android 3.0开始，Bitmap被放置到了堆中，其内存由GC管理，所以不用手动调用bitmap.recycle()方法进行释放了；</li>
</ul>
<ul>
<li>使用图片缓存：设计内存缓存(LruCache)和磁盘缓存(DiskLruCache)可以更好地利用Bitmap。</li>
</ul>
<p>(2)代码优化</p>
<ul>
<li>对常量使用static修饰</li>
</ul>
<ul>
<li>使用静态方法，它比普通方法会提高15%左右的访问速度；</li>
<li>减少不必要的成员变量，这点Android lint工具已经集成检验啦。</li>
</ul>
<ul>
<li>尽量不要使用枚举（枚举逻辑更加清晰，相比静态常量效率更低），少用迭代器。</li>
</ul>
<ul>
<li>对Cursor、Receiver、Sensor、File等对象，要非常注意对它们的创建、回收与注册、解注册；</li>
<li>避免使用IOC框架，IOC框架使用注解反射来实现。Java反射效率已经有了很好的优化，但大量使用依然会使效率下降。</li>
<li>使用RenderScript，OpenGl来进行复杂的绘图操作。</li>
</ul>
<ul>
<li>使用SurfaceView来替代view进行大量的、频繁的绘图操作；</li>
</ul>
<ul>
<li>尽量使用视图缓存，而不是每次都执行inflate方法解析视图。</li>
</ul>
<p>3.其他的辅助工具<br>(1)、Lint工具：代码提示工具，可以用来发现代码中隐藏的一些问题。</p>
<p>(2)、Memory Monitor工具：内存监视工具。突然走高可能发生内存泄漏，内存减少可能系统在GC。</p>
<p>(3)、TraceView工具：可视化性能调查工具，它用来分析TraceView日志</p>
<p>(4)、MAT工具：内存分析工具</p>
<p>(5)dumpsys命令：该命令可以列出android系统相关的信息和服务状态，可使用的配置参数很多，常见的有：<br><code>activity</code>：显示所有Activity栈的信息；<br><code>meminfo</code>：显示内存信息；<br><code>battery</code>：显示电池信息；<br><code>package</code>：显示包信息；<br>3.其他的辅助工具<br>(1)Lint工具：代码提示工具，可以用来发现代码中隐藏的一些问题<br>(2)Memory Monitor工具：内存监视工具<br>(3)TraceView工具：可视化性能调查工具，它用来分析TraceView日志<br>(4)MAT工具：内存分析工具<br>(5)dumpsys命令：该命令可以列出android系统相关的信息和服务状态，可使用的配置参数很多，常见的有：<br><code>activity</code>：显示所有Activity栈的信息；<br><code>meminfo</code>：显示内存信息；<br><code>battery</code>：显示电池信息；<br><code>package</code>：显示包信息；<br><code>wifi</code>：显示wifi信息；<br><code>alarm</code>：显示alarm信息；<br><code>procstats</code>：显示内存状态</p>
<h4 id="第十一章-云端服务器"><a href="#第十一章-云端服务器" class="headerlink" title="第十一章 云端服务器"></a>第十一章 云端服务器</h4><p>1.1、移动后端云：Backend as a service 即baas。</p>
<p>移动开发者不用在考虑如何租服务器、如何设计数据库、搭建服务器等，只要需调用api接口，就可以实现网络功能。后端云服务器一般包括数据存储、消息推送、文件服务、API分析、应用统计、移动官网。</p>
<h4 id="第十二章-Material-Design"><a href="#第十二章-Material-Design" class="headerlink" title="第十二章 Material Design"></a>第十二章 Material Design</h4><p>2014Google 携带 Android5.x重装归来。最为核心的就是Material  Design。</p>
<p>材料的形态模拟是Materila Design的设计核心思想所在。通过模拟自然界纸墨的变化、光线和阴影、纸与纸之间的空间层次关系，带来一种真实感。</p>
<p>Material  Design 大量引入了各种新的动画效果，让整个设计风格更加自然、和谐 。各种全新的转场动画指引用户的视觉焦点，使用户达到视觉的连贯性。</p>
<p>1.1、Palette</p>
<p>调色板,获取bitmap中的颜色信息，用以造成空指针，使用palette.getXXXColor(int defaltColot)获取颜色信息会更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取builder对象，又一个建造者模式</span></span><br><span class="line">Palette.Builder builder = Palette.from(bitmap);</span><br><span class="line">builder.generate(<span class="keyword">new</span> Palette.PaletteAsyncListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGenerated</span><span class="params">(Palette palette)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//充满活力</span></span><br><span class="line">        Palette.Swatch vibrantSwatch = palette.getVibrantSwatch();</span><br><span class="line">        <span class="keyword">int</span> rgb = <span class="number">0xff000000</span>;</span><br><span class="line">        <span class="keyword">if</span> (vibrantSwatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rgb = vibrantSwatch.getRgb();</span><br><span class="line">            setStatueBarColor(rgb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//充满活力的亮</span></span><br><span class="line">        Palette.Swatch lightVibrantSwatch = palette.getLightVibrantSwatch();</span><br><span class="line">        <span class="keyword">if</span> (lightVibrantSwatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rgb = lightVibrantSwatch.getRgb();</span><br><span class="line">            setStatueBarColor(rgb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//充满活力的黑</span></span><br><span class="line">        Palette.Swatch darkVibrantSwatch = palette.getDarkVibrantSwatch();</span><br><span class="line">        <span class="keyword">if</span> (darkVibrantSwatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rgb = darkVibrantSwatch.getRgb();</span><br><span class="line">            setStatueBarColor(rgb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//柔和的</span></span><br><span class="line">        Palette.Swatch mutedSwatch = palette.getMutedSwatch();</span><br><span class="line">        <span class="keyword">if</span> (mutedSwatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rgb = mutedSwatch.getRgb();</span><br><span class="line">            setStatueBarColor(rgb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//柔和的亮</span></span><br><span class="line">        Palette.Swatch lightMutedSwatch = palette.getLightMutedSwatch();</span><br><span class="line">        <span class="keyword">if</span> (lightMutedSwatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rgb = lightMutedSwatch.getRgb();</span><br><span class="line">            setStatueBarColor(rgb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//柔和的黑</span></span><br><span class="line">        Palette.Swatch darkMutedSwatch = palette.getDarkMutedSwatch();</span><br><span class="line">        <span class="keyword">if</span> (darkMutedSwatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rgb = darkMutedSwatch.getRgb();</span><br><span class="line">            setStatueBarColor(rgb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>1.2、视图与阴影。</p>
<p>Google给View增加了一个全新的属性 z ，表示View在 z 方向上的高度，有以下公式来描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z &#x3D; elevation + translationZ;</span><br></pre></td></tr></table></figure>

<p>1.3、tint与clipping</p>
<p>1.4列表与卡片</p>
<p>主要介绍RecyclerView和CardView的简单使用。</p>
<p>1.5、Activity Transition</p>
<p>Android5.0提供了三种Transition类型</p>
<ul>
<li>进入：决定Acitivity中的所有视图如何进入屏幕。</li>
<li>推出：决定Activity中的所有视图如何退出屏幕。</li>
<li>共享元素：决定两个Activity之间的多度，如何共享它们之间的视图。</li>
</ul>
<p>其中进入和推出效果包括：</p>
<ul>
<li>explode：分解效果，Activity的进入或退出，从屏幕的的中间移动视图。</li>
<li>slide：滑动效果，Activity的进入或退出，从屏幕的的边缘移动视图。</li>
<li>fade：淡入淡出效果，通过改变Activity视图的不透明度达到添加或移除视图。</li>
</ul>
<p>共享元素包括</p>
<ul>
<li>changeBounds：改变视图的边界。</li>
<li>changeClipBounds：剪切视图的边界。</li>
<li>changeTransform：改变目标视图的缩放比例和旋转角度。</li>
<li>changeImageTransform：改变目标图片的大小和旋转角度。</li>
</ul>
<p>只能兼容5.0以上，推荐使用AcitivityOptionsCompat下的几种转场动画。然后大部分Rom已经屏蔽了Activity的转场动画，设置并没有什么卵用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启打开Activity的转场动画</span></span><br><span class="line">startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(<span class="keyword">this</span>).toBundle());</span><br><span class="line"><span class="comment">//在打开一个Activity中设置</span></span><br><span class="line">getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</span><br><span class="line"><span class="keyword">int</span> flag = getIntent().getExtras().getInt(<span class="string">"flag"</span>);</span><br><span class="line"><span class="comment">// 设置不同的动画效果</span></span><br><span class="line"><span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        getWindow().setEnterTransition(<span class="keyword">new</span> Explode());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        getWindow().setEnterTransition(<span class="keyword">new</span> Slide());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        getWindow().setEnterTransition(<span class="keyword">new</span> Fade());</span><br><span class="line">        getWindow().setExitTransition(<span class="keyword">new</span> Fade());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.6、Material Design的动画效果。</p>
<ul>
<li><p>Ripple效果：5.0以上默认有ripple效果，可以通过一下方式设置不同的效果。但是不向下兼容。Github有兼容库，在任何的控件上都可以实现Ripple的点击效果。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置有边界</span></span><br><span class="line">android:background=<span class="string">"?android:attr/selectableItemBackground"</span></span><br><span class="line"><span class="comment">//设置无边界 </span></span><br><span class="line">android:background=<span class="string">"?android:attr/selectableItemBackgroundBorderless"</span></span><br><span class="line"><span class="comment">//xml ripple效果</span></span><br><span class="line">&lt;ripple xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">        android:color=<span class="string">"@color/colorPrimary"</span>&gt;</span><br><span class="line">&lt;/ripple&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>Circuler Reveal：具体表现为一个View以一个圆形的方式展开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = ViewAnimationUtils.createCircularReveal(</span><br><span class="line">		view,    <span class="comment">//动画作用的View</span></span><br><span class="line">		view.getWidth()/<span class="number">2</span>,   <span class="comment">//开始圆心X</span></span><br><span class="line">        view.getHeight()/<span class="number">2</span>,	 <span class="comment">//开始圆心Y</span></span><br><span class="line">        <span class="number">0</span>,                  <span class="comment">//开始时半径的大小  </span></span><br><span class="line">  		view.getWidth()/<span class="number">2</span>); <span class="comment">//结束时半径的大小</span></span><br><span class="line">animator.setDuration(<span class="number">1000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>视图状态变化动画：</p>
<ul>
<li><p>StateListAnim可以根据view的状态改变呈现不同的动画效果，通过XML构建不同的状态集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器动画</span></span><br><span class="line">&lt;selector xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;item android:state_pressed=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;objectAnimator android:duration=<span class="string">"500"</span></span><br><span class="line">                            android:propertyName=<span class="string">"rotationX"</span></span><br><span class="line">                            android:valueTo=<span class="string">"360"</span></span><br><span class="line">                            android:valueType=<span class="string">"floatType"</span>/&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line">    &lt;item android:state_pressed=<span class="string">"false"</span>&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;objectAnimator android:duration=<span class="string">"500"</span></span><br><span class="line">                            android:propertyName=<span class="string">"rotationX"</span></span><br><span class="line">                            android:valueTo=<span class="string">"0"</span></span><br><span class="line">                            android:valueType=<span class="string">"floatType"</span>/&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line">&lt;/selector&gt;</span><br><span class="line"><span class="comment">//给View设置动画</span></span><br><span class="line">&lt;Button</span><br><span class="line">    android:id=<span class="string">"@+id/state_list_animation"</span></span><br><span class="line">    android:stateListAnimator=<span class="string">"@drawable/anim_change"</span></span><br><span class="line">    android:layout_width=<span class="string">"100dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"100dp"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也通过代码的形式设置动画</span></span><br><span class="line">StateListAnimator animator = AnimatorInflater.loadStateListAnimator</span><br><span class="line">      	(mContext,R.drawable.anim_change);</span><br><span class="line">mImageView.setStateListAnimator(animator);</span><br></pre></td></tr></table></figure>
</li>
<li><p>animated-selector：动画状态选择器。具体表现为一个View的点击又多张图片组合而成的帧动画，典型的就是系统的chect-box。</p>
</li>
</ul>
</li>
</ul>
<h4 id="第十三章-实例提高"><a href="#第十三章-实例提高" class="headerlink" title="第十三章 实例提高"></a>第十三章 实例提高</h4>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/01/13/%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84CrashHandler%E7%94%A8%E6%B3%95/" rel="prev" title="你应该了解的CrashHandler用法">
      <i class="fa fa-chevron-left"></i> 你应该了解的CrashHandler用法
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/04/06/%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%AC%E4%B8%89%E7%AB%A0View%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/" rel="next" title="Android开发艺术探索第三章-View事件">
      Android开发艺术探索第三章-View事件 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-Heroes"><span class="nav-number">1.</span> <span class="nav-text">Android Heroes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一章-Android体系和系统架构"><span class="nav-number">1.0.1.</span> <span class="nav-text">第一章  Android体系和系统架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二章-Android-开发工具"><span class="nav-number">1.0.2.</span> <span class="nav-text">第二章 Android 开发工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三章-Android控件架构与自定义控件详解"><span class="nav-number">1.0.3.</span> <span class="nav-text">第三章 Android控件架构与自定义控件详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四章-ListView使用技巧"><span class="nav-number">1.0.4.</span> <span class="nav-text">第四章 ListView使用技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第五章-Android-Scroll分析"><span class="nav-number">1.0.5.</span> <span class="nav-text">第五章 Android Scroll分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第六章-Android绘图机制与处理技巧"><span class="nav-number">1.0.6.</span> <span class="nav-text">第六章 Android绘图机制与处理技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第七章-Android动画机制与使用技巧"><span class="nav-number">1.0.7.</span> <span class="nav-text">第七章 Android动画机制与使用技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第八章-activity与activity调用栈分析"><span class="nav-number">1.0.8.</span> <span class="nav-text">第八章 activity与activity调用栈分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第九章-Android系统信息与安全机制"><span class="nav-number">1.0.9.</span> <span class="nav-text">第九章 Android系统信息与安全机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第十章-Android性能优化"><span class="nav-number">1.0.10.</span> <span class="nav-text">第十章 Android性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第十一章-云端服务器"><span class="nav-number">1.0.11.</span> <span class="nav-text">第十一章 云端服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第十二章-Material-Design"><span class="nav-number">1.0.12.</span> <span class="nav-text">第十二章 Material Design</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第十三章-实例提高"><span class="nav-number">1.0.13.</span> <span class="nav-text">第十三章 实例提高</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Koterwong"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Koterwong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/koterwong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;koterwong" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:koterwong@gmail.com" title="E-Mail → mailto:koterwong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Koterwong</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'owszTwWNkskIjjkFrAO3ErXj-gzGzoHsz',
      appKey: 'Ssyw9IJHW5cWHfzllcl2NHQh',
      placeholder: "说点什么吧~",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
